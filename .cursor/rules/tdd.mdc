### 目的

このプロンプトの目的は、明確な**要件**と**制約**に基づいて、**機能的でテスト可能なコード**を開発することです。**TDD (テスト駆動開発) の思想**を取り入れ、**DRY (Don't Repeat Yourself) 原則**を遵守した、**高品質で堅牢なコード**の作成を目指します。

---

### 要件

* **機能的要件**:  design_doc_time_tracker_go.md　と　prd_time_tracker_go.md と ui_design_specification.md と　ui_design_specification.drawioを参考にすること。
* **非機能的要件**: logging_specification.md を参考にすること
* **依存関係と環境**: 
* **ドキュメンテーション**: **要件定義書、設計書** : 現状なし

---

### 留意点

1.  **計画（Plan）の作成**:
    * **TDDのアプローチ**: **テスト駆動開発の思想**に基づき、**最初にテストを設計し、その後でコードを実装する**アプローチを計画に含めてください。
    * **要件定義と設計**: 上記の「要件」セクションの内容を深く理解し、具体的なシステムの**アーキテクチャ、モジュール構造、データフロー、APIインターフェース**などを計画してください。このフェーズで**要件定義書**や**設計書**にまとめるべき内容を明確にしてください。
    * **主要コンポーネントのリストアップ**: コードを構成する主要なコンポーネントやモジュールを列挙し、それぞれの**役割**を明確にしてください。
    * **コンポーネント連携の設計**: 各コンポーネントがどのように相互作用し、データを受け渡しするかを具体的に説明してください。
    * **アルゴリズムとアプローチ**: 問題を解決するための具体的なアルゴリズムやアプローチについて詳細に記述してください。考慮した代替案があれば、その選定理由も簡潔に述べてください。
    * **エッジケースと問題点**: 考慮すべき**エッジケース**（例: 無効な入力、空のデータ、境界値など）や潜在的な問題点を特定し、それらに対する**具体的な対応策**を検討してください。
    * **DRY原則の考慮**: 計画段階から**DRY原則**を意識し、再利用可能なコンポーネントや共通ロジックの抽出を検討してください。
    * **段階的な実装**: **最小機能ごとにフェーズを分け、各フェーズで計画、テストコード作成、コード実装、そして必要に応じてファイルの生成指示を行う**ことを明確にしてください。
    * **ユーザーへの確認**: 計画を立て終わったら、次に進む前にユーザーへ計画内容を確認してください。

2.  **テストコードの作成**:
    * **TDDの思想**に基づき、**コードを実装する前に**、作成する機能の振る舞いを定義するテストコードを作成してください。
    * テストは可能な限り**独立**しており、特定の機能や振る舞いを明確に検証できるように設計してください。
    * **テストケース**は、上記の**すべての要件**（機能的、非機能的など）をカバーするように設計してください。
    * 特に重要な機能や、複雑なロジックを持つ部分については、**重点的にテスト**してください。
    * **エッジケース**や**エラー処理**に関するテストも必ず含めてください。
    * **ユーザーへの確認**: テストコードの生成が終わったら、次に進む前にユーザーへテストコードの内容を確認してください。

3.  **コードの実装**:
    * 作成した**テストがすべてパスするように**、上記の計画と設計に基づき、要求されたコードを作成してください。
    * **DRY原則の遵守**: コードの重複を避け、共通のロジックや機能は再利用可能な形で実装してください。
    * **可読性が高く、保守しやすいコード**を心がけてください。
    * **適切なコメント**（特に複雑なロジックや意図が分かりにくい部分）や**ドキュメント**（関数やクラスの目的、引数、戻り値など）を記述してください。

4.  **UI/UXコンポーネントの実装時の注意事項**:
    * **イベントハンドリングの実装**:
      - クリックイベントが正しく動作しない場合、**イベント伝播の防止**を必ず実装してください。
      - `e.preventDefault()`, `e.stopPropagation()`, `e.nativeEvent.stopImmediatePropagation()` を適切に使用してください。
      - 親要素のクリックイベントが子要素のクリックを妨げる可能性を常に考慮してください。
    
    * **条件分岐の可視化**:
      - コンポーネントが表示されない条件を**デバッグ用の視覚的要素**で明示してください。
      - 開発中は条件分岐の状態を確認できるよう、一時的なデバッグ表示を追加してください。
      - 例: `{!condition && <div style={{color: 'red'}}>Debug: condition is false</div>}`
    
    * **CSSとレイアウトの確認**:
      - ボタンやインタラクティブ要素が他の要素に隠れていないか確認してください。
      - `z-index`, `position`, `overflow` プロパティを適切に設定してください。
      - 開発中は一時的に目立つスタイル（赤い枠、黄色い背景など）を適用して可視性を確保してください。
    
    * **デバッグログの実装**:
      - クリックイベントや重要な状態変更には**console.log**を追加してください。
      - イベントハンドラーが呼び出されているか、条件分岐が正しく動作しているかを確認できるログを実装してください。
      - 本番環境では適切にログを削除または無効化してください。
    
    * **コンポーネント間の連携確認**:
      - 親コンポーネントから子コンポーネントへの**propsの受け渡し**が正しく行われているか確認してください。
      - 条件付きレンダリングの条件が適切に設定されているか確認してください。
      - 関数型props（onClick, onEdit等）が正しく渡されているか確認してください。

5.  **問題解決の手順**:
    * **症状の特定**: ボタンが反応しない、コンポーネントが表示されない等の症状を明確にしてください。
    * **原因の切り分け**: 
      1. コンポーネントが表示されているか（視覚的確認）
      2. イベントハンドラーが呼び出されているか（ログ確認）
      3. 条件分岐が正しく動作しているか（デバッグ表示確認）
      4. CSSの問題がないか（スタイル確認）
    * **段階的な修正**: 一度に複数の修正を行わず、一つずつ修正して動作確認を行ってください。
    * **テストの更新**: 修正後は関連するテストが正常に動作することを確認してください。

6.  **品質保証**:
    * **統合テスト**: フロントエンドとバックエンドの連携が正常に動作することを確認してください。
    * **ユーザビリティテスト**: 実際のユーザー操作で問題がないことを確認してください。
    * **エラーハンドリング**: 予期しない入力や状態に対する適切な処理を実装してください。
    * **可読性が高く、保守しやすいコード**を心がけてください。
    * **適切なコメント**（特に複雑なロジックや意図が分かりにくい部分）や**ドキュメント**（関数やクラスの目的、引数、戻り値など）を記述してください。

7.  **Tauriアプリケーション固有の注意事項**:
    * **Tauriコマンドのパラメータ形式統一**:
      - **データ作成・更新・削除コマンド**: パラメータを`request`オブジェクトでラップする
        ```typescript
        // 正しい形式
        await invoke('create_task', {
          request: {
            project_id: projectId,
            name: taskName
          }
        })
        
        // 間違った形式（避けるべき）
        await invoke('create_task', {
          project_id: projectId,
          name: taskName
        })
        ```
      - **データ取得コマンド**: 直接パラメータを渡す
        ```typescript
        // 正しい形式
        await invoke('get_project', { id: projectId })
        await invoke('get_timer_status', { task_id: taskId })
        ```
      - **パラメータ形式の確認**: 新しいコマンドを実装する際は、バックエンドの関数シグネチャを必ず確認し、フロントエンドの呼び出し形式と一致させる
        ```rust
        // バックエンド側の例
        pub async fn create_task(
            app_service: State<'_, ApplicationService>,
            request: CreateTaskRequest,  // ← requestオブジェクトを期待
        ) -> Result<TaskDto, String>
        
        pub async fn get_project(
            app_service: State<'_, ApplicationService>,
            id: i64,  // ← 直接パラメータを期待
        ) -> Result<Option<ProjectDto>, String>
        ```
    
    * **Tauriコマンドのテスト実装**:
      - フロントエンドのテストでは、`invoke`の呼び出し形式が正しいことを確認するテストを含める
      - 統合テストでは、実際のTauriコマンドが正常に動作することを確認する
      - エラーケースのテストも含め、パラメータ形式が間違っている場合のエラーハンドリングを検証する
    
    * **デバッグとトラブルシューティング**:
      - Tauriコマンドが呼ばれない場合、パラメータ形式を最初に確認する
      - バックエンドのログが出力されない場合、フロントエンドの呼び出し形式を疑う
      - 新しいコマンドを追加する際は、既存のコマンドの形式を参考にする
      - コマンドの登録漏れがないか`main.rs`の`invoke_handler`を確認する
